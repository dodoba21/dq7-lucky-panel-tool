<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DQ7 幸運翻牌攻略工具（中文版）</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --card: #ffffff;
      --line: #dde2ea;
      --text: #1f2937;
      --muted: #6b7280;
      --danger: #dc2626;
      --ok: #0f766e;
      --accent: #2563eb;
      --sel: #ef4444;
      --shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Noto Sans TC", "Microsoft JhengHei", sans-serif;
      color: var(--text);
      background: radial-gradient(circle at 10% 5%, #ffffff 0%, #f3f6ff 40%, #edf1f8 100%);
    }

    .page {
      width: min(1080px, 96vw);
      margin: 20px auto 28px;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px;
    }

    h1 {
      margin: 0;
      font-size: clamp(20px, 3vw, 30px);
      line-height: 1.25;
    }

    .sub {
      margin-top: 8px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.6;
    }

    .steps {
      margin: 0;
      padding-left: 18px;
      line-height: 1.7;
      font-size: 15px;
    }

    .steps li + li { margin-top: 4px; }

    .mode-tabs {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }

    .mode-tabs input { display: none; }

    .mode-tabs label {
      display: block;
      border: 1px solid #c9d1de;
      border-radius: 8px;
      text-align: center;
      padding: 10px 8px;
      cursor: pointer;
      font-weight: 700;
      background: #fff;
      user-select: none;
    }

    .mode-tabs input:checked + label {
      border-color: #111827;
      color: #fff;
      background: linear-gradient(to bottom, #4b5563, #1f2937);
    }

    .status {
      text-align: center;
      font-weight: 700;
      min-height: 24px;
      line-height: 1.4;
      margin-bottom: 8px;
      color: var(--danger);
    }

    .status .count {
      display: inline-block;
      margin-top: 4px;
      padding: 3px 10px;
      border-radius: 999px;
      background: #fef08a;
      color: #b91c1c;
    }

    .board {
      display: grid;
      gap: 7px;
      background: #eff2f6;
      border: 1px solid #d7dce5;
      border-radius: 10px;
      padding: 8px;
      min-height: 220px;
    }

    .cell {
      position: relative;
      border: 1px solid #eceff4;
      border-radius: 7px;
      background: #fff;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.75) inset, 0 1px 4px rgba(31,41,55,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(22px, 3.2vw, 30px);
      font-weight: 800;
      user-select: none;
      cursor: pointer;
      transition: transform .15s ease, filter .15s ease;
    }

    .cell:hover { filter: brightness(0.98); }

    .cell.back {
      background:
        repeating-linear-gradient(135deg, #9fb2cc 0, #9fb2cc 10px, #8ca1bd 10px, #8ca1bd 20px);
      border: 4px solid #fff;
      color: rgba(0, 0, 0, 0);
    }

    .cell.selected {
      background: #ff5b5b !important;
      border-color: #d11f1f !important;
      transform: scale(1.08);
      z-index: 3;
    }

    .cell[data-token="A"] { background: #4fc3f7; }
    .cell[data-token="B"] { background: #ffa726; }
    .cell[data-token="C"] { background: #d4e157; }
    .cell[data-token="D"] { background: #4db6ac; }
    .cell[data-token="E"] { background: #ba68c8; }
    .cell[data-token="F"] { background: #a1887f; }
    .cell[data-token="G"] { background: #4dd0e1; }
    .cell[data-token="H"] { background: #ffd54f; }
    .cell[data-token="I"] { background: #7986cb; }
    .cell[data-token="J"] { background: #90a4ae; }
    .cell[data-token="K"] { background: #81c784; }

    .cell[data-token="X"] {
      background: #edece5;
      font-size: clamp(14px, 2.2vw, 18px);
      letter-spacing: 1px;
    }

    .cell[data-token="Y"] {
      background: #374151;
      color: #fff;
      font-size: clamp(14px, 2.2vw, 18px);
      letter-spacing: 1px;
    }

    .log {
      position: absolute;
      top: 4px;
      left: 5px;
      color: var(--danger);
      font-size: 13px;
      line-height: 1;
      font-weight: 900;
      min-height: 14px;
      text-align: left;
      pointer-events: none;
    }

    .next-mode {
      margin-top: 10px;
      width: 100%;
      border: 1px solid #c91d1d;
      color: #fff;
      background: linear-gradient(to bottom, #ef5350, #e53935 50%, #d32f2f 51%, #f44336);
      border-radius: 8px;
      font-size: 16px;
      font-weight: 700;
      padding: 11px;
      cursor: pointer;
    }

    .actions {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
    }

    .btn {
      border: 1px solid #c2c8d4;
      border-radius: 8px;
      background: linear-gradient(to bottom, #fff, #eef2f7);
      font-weight: 700;
      font-size: 14px;
      padding: 10px;
      cursor: pointer;
    }

    .hint {
      margin-top: 10px;
      color: #374151;
      font-size: 13px;
      line-height: 1.6;
      background: #f8fafc;
      border: 1px dashed #c7d2e2;
      border-radius: 8px;
      padding: 8px 10px;
    }

    @media (max-width: 860px) {
      .page { width: min(720px, 96vw); }
    }
  </style>
</head>
<body>
  <div class="page">
    <section class="panel">
      <h1>DQ7 幸運翻牌攻略工具（中文版）</h1>
      <div class="sub">用途：把遊戲內牌面先輸入到這裡，再依照實際洗牌結果做交換，最後照工具上的位置回遊戲配對。</div>
    </section>

    <section class="panel">
      <ol class="steps">
        <li>先依照遊戲畫面，按順序點擊格子輸入牌面（最後兩格固定是「機會牌」與「洗牌牌」）。</li>
        <li>進入洗牌階段後，每次洗牌都在這裡點 2 格交換，直到剩餘次數歸零。</li>
        <li>完成後照畫面回遊戲翻牌；左上角紅字是該格參與過的洗牌次序。</li>
      </ol>
    </section>

    <section class="panel" id="toolRoot">
      <div class="mode-tabs" id="modeTabs"></div>

      <div class="status" id="status"></div>

      <div class="board" id="board"></div>

      <button class="next-mode" id="nextModeBtn" style="display:none;"></button>

      <div class="actions">
        <button class="btn" id="reshuffleBtn" style="display:none;">重做洗牌輸入</button>
        <button class="btn" id="resetBtn">全部重置（從頭輸入）</button>
      </div>

      <div class="hint">
        小提醒：
        1) 輸入階段若點錯，可再點一次「剛輸入的那一格」回退。
        2) 洗牌階段必須一次點兩格才會交換。
      </div>
    </section>
  </div>

  <script>
    (function () {
      const MODES = {
        "1": {
          label: "甘口",
          cols: 4,
          rows: 3,
          count: 12,
          shuffleLimit: 2,
          sequence: ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E", "X", "Y"]
        },
        "2": {
          label: "中辛",
          cols: 4,
          rows: 4,
          count: 16,
          shuffleLimit: 3,
          sequence: ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E", "F", "F", "G", "G", "X", "Y"]
        },
        "3": {
          label: "辛口",
          cols: 5,
          rows: 4,
          count: 20,
          shuffleLimit: 5,
          sequence: ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E", "F", "F", "G", "G", "H", "H", "I", "I", "X", "Y"]
        },
        "4": {
          label: "激辛",
          cols: 6,
          rows: 4,
          count: 24,
          shuffleLimit: 7,
          sequence: ["A", "A", "B", "B", "C", "C", "D", "D", "E", "E", "F", "F", "G", "G", "H", "H", "I", "I", "J", "J", "K", "K", "X", "Y"]
        }
      };

      const MODE_ORDER = ["1", "2", "3", "4"];
      const CIRCLED = ["", "①", "②", "③", "④", "⑤", "⑥", "⑦", "⑧", "⑨", "⑩"];

      const modeTabs = document.getElementById("modeTabs");
      const statusEl = document.getElementById("status");
      const boardEl = document.getElementById("board");
      const nextModeBtn = document.getElementById("nextModeBtn");
      const reshuffleBtn = document.getElementById("reshuffleBtn");
      const resetBtn = document.getElementById("resetBtn");

      const state = {
        mode: "1",
        phase: "input", // input | shuffle | finish
        cells: Array(24).fill(""),
        selectedA: null,
        selectedB: null,
        swapping: false,
        shuffleCount: 0,
        logs: [],
        inputSnapshot: ""
      };

      function modeCfg() {
        return MODES[state.mode];
      }

      function visibleCount() {
        return modeCfg().count;
      }

      function filledCount() {
        const n = visibleCount();
        let c = 0;
        for (let i = 0; i < n; i++) {
          if (state.cells[i] !== "") c++;
        }
        return c;
      }

      function tokenText(token) {
        if (token === "X") return "機會";
        if (token === "Y") return "洗牌";
        return token;
      }

      function cycleModeText() {
        const idx = MODE_ORDER.indexOf(state.mode);
        const next = MODE_ORDER[(idx + 1) % MODE_ORDER.length];
        if (next === "1") return "回到【甘口】";
        return "前往下一難度【" + MODES[next].label + "】";
      }

      function nextModeValue() {
        const idx = MODE_ORDER.indexOf(state.mode);
        return MODE_ORDER[(idx + 1) % MODE_ORDER.length];
      }

      function resetAll() {
        state.phase = "input";
        state.cells = Array(24).fill("");
        state.selectedA = null;
        state.selectedB = null;
        state.swapping = false;
        state.shuffleCount = 0;
        state.logs = [];
        state.inputSnapshot = "";
      }

      function resetForModeChange() {
        resetAll();
        render();
      }

      function restoreFromInputSnapshot() {
        state.phase = "shuffle";
        state.selectedA = null;
        state.selectedB = null;
        state.swapping = false;
        state.shuffleCount = 0;
        state.logs = [];

        if (!state.inputSnapshot) return;
        try {
          const list = JSON.parse(state.inputSnapshot);
          state.cells = Array(24).fill("");
          for (let i = 0; i < list.length && i < 24; i++) {
            state.cells[i] = list[i] || "";
          }
        } catch (e) {
          // keep current state if parse failed
        }
      }

      function getCellLogs(cellIndex) {
        if (state.phase !== "finish") return "";
        const indexes = [];
        for (let i = 0; i < state.logs.length; i++) {
          const pair = state.logs[i];
          if (pair[0] === cellIndex + 1 || pair[1] === cellIndex + 1) {
            indexes.push(i + 1);
          }
        }
        return indexes.map(function (n) {
          return CIRCLED[n] || String(n);
        }).join("");
      }

      function onInputClick(i) {
        const cfg = modeCfg();
        const count = filledCount();
        const token = state.cells[i];

        if (token === "") {
          state.cells[i] = cfg.sequence[count];
          if (count + 1 === cfg.count) {
            state.phase = "shuffle";
            state.inputSnapshot = JSON.stringify(state.cells.slice(0, cfg.count));
          }
          return;
        }

        // replicate original rollback rule
        if (count % 2 === 0) {
          if (token === cfg.sequence[count - 1]) {
            state.cells[i] = "";
          }
        } else {
          if (token === cfg.sequence[count]) {
            state.cells[i] = "";
          }
        }
      }

      function doSwap(a, b) {
        const t = state.cells[a];
        state.cells[a] = state.cells[b];
        state.cells[b] = t;
      }

      function onShuffleClick(i) {
        if (state.swapping) return;

        if (state.selectedA === null) {
          state.selectedA = i;
          return;
        }

        if (state.selectedA === i) {
          state.selectedA = null;
          return;
        }

        state.selectedB = i;
        state.swapping = true;

        window.setTimeout(function () {
          doSwap(state.selectedA, state.selectedB);
          state.logs.push([state.selectedA + 1, state.selectedB + 1]);
          state.selectedA = null;
          state.selectedB = null;
          state.shuffleCount += 1;
          state.swapping = false;

          if (state.shuffleCount >= modeCfg().shuffleLimit) {
            state.phase = "finish";
          }
          render();
        }, 200);
      }

      function onCellClick(index) {
        const max = visibleCount();
        if (index >= max) return;

        if (state.phase === "input") {
          onInputClick(index);
          render();
          return;
        }

        if (state.phase === "shuffle") {
          onShuffleClick(index);
          render();
        }
      }

      function renderTabs() {
        modeTabs.innerHTML = "";
        MODE_ORDER.forEach(function (modeKey, idx) {
          const cfg = MODES[modeKey];

          const wrap = document.createElement("div");
          const id = "mode-" + modeKey;

          const input = document.createElement("input");
          input.type = "radio";
          input.name = "mode";
          input.id = id;
          input.checked = state.mode === modeKey;
          input.addEventListener("change", function () {
            state.mode = modeKey;
            resetForModeChange();
          });

          const label = document.createElement("label");
          label.setAttribute("for", id);
          label.textContent = cfg.label;

          wrap.appendChild(input);
          wrap.appendChild(label);
          modeTabs.appendChild(wrap);
        });
      }

      function renderStatus() {
        const cfg = modeCfg();

        if (state.phase === "input") {
          statusEl.textContent = "輸入階段：請依照遊戲順序點格子";
        } else if (state.phase === "shuffle") {
          const left = cfg.shuffleLimit - state.shuffleCount;
          statusEl.innerHTML = "洗牌階段<br><span class='count'>剩餘次數：" + left + "</span>";
        } else {
          statusEl.innerHTML = "輸入完成，請照此盤面回遊戲操作。<br><small>左上紅字是洗牌歷程</small>";
        }

        reshuffleBtn.style.display = state.phase === "input" ? "none" : "inline-block";
        nextModeBtn.style.display = state.phase === "finish" ? "block" : "none";
        nextModeBtn.textContent = cycleModeText();
      }

      function renderBoard() {
        const cfg = modeCfg();

        boardEl.style.gridTemplateColumns = "repeat(" + cfg.cols + ", 1fr)";
        boardEl.style.gridTemplateRows = "repeat(" + cfg.rows + ", minmax(76px, 1fr))";

        boardEl.innerHTML = "";
        for (let i = 0; i < cfg.count; i++) {
          const token = state.cells[i];
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "cell";

          if (token === "") {
            btn.classList.add("back");
            btn.textContent = "?";
          } else {
            btn.dataset.token = token;
            btn.textContent = tokenText(token);
          }

          if (state.selectedA === i || state.selectedB === i) {
            btn.classList.add("selected");
          }

          const log = document.createElement("span");
          log.className = "log";
          log.textContent = getCellLogs(i);
          btn.appendChild(log);

          btn.addEventListener("click", function () {
            onCellClick(i);
          });

          boardEl.appendChild(btn);
        }
      }

      function render() {
        renderTabs();
        renderStatus();
        renderBoard();
      }

      reshuffleBtn.addEventListener("click", function () {
        restoreFromInputSnapshot();
        render();
      });

      resetBtn.addEventListener("click", function () {
        resetAll();
        render();
      });

      nextModeBtn.addEventListener("click", function () {
        if (state.phase !== "finish") return;
        state.mode = nextModeValue();
        resetForModeChange();
      });

      render();
    })();
  </script>
</body>
</html>
